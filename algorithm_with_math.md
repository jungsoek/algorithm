# 1. 알고리즘과 수학의 관계

## 1.1. 알고리즘이란?

알고리즘은 "문제를 해결하는 과정"을 의미한다.

### 1.1.1. 알고리즘의 예(1) : 하나씩 더하기

1부터 100까지 정수를 모두 더하는 문제를 생각해보자. 1부터 100까지 하나씩 더해가면 연산량이 매우 많다.

### 1.1.2. 알고리즘의 예(2) : 변형해서 한 번에 계산하기

1부터 100까지의 수를 보면 양 끝의 수를 더하면 모두 101이 된다. 해서 총 50쌍의 101이 나오게되는데 이를 통해 답을 금방 구할 수 있다.

알고리즘의 예(1)에서보다 훨씬 효율적인 알고리즘이다.

### 1.1.3. 다양한 문제를 풀 때 도움이 되는 알고리즘

지금까지는 단순한 계산 문제를 이야기했지만, 알고리즘의 적용 범위는 훨씬 넓다. 예를 들어 다음과 같이 생활에서 직면할 수 있는 다양한 문제들을 해결할 때 활용할 수 있다.

* 김포공항역에서 판교역까지 최단 경로 구하기(4.5절)
* 5000원을 갖고 편의점에서 구매할 수 있는 칼로리가 가장 많은 제품 조합 구하기(3.7절)
* 일정 기간 동안 놀이공원에 방문한 방문객 합계를 빠르게 계산하기(4.2절)
* 기말시험 결과를 성적 순서로 정렬하기(3.6절)
* 가장 적은 양의 지폐로 대금을 계산하는 방법 구하기(5.9절)
* 가능한 한 많은 영화를 보는 방법 찾기(5.9절)
* 사전에 "technology"라는 단어의 의미 찾기(2.4절)

예를 들어서 마지막 사전 예는 익숙할 것이다. 사전의 가장 앞부분부터 단어를 하나하나 "a →aardvark→aback→abacus→abalone→abandon→..." 처럼 찾는다면, technology라는 단어를 찾는 데 굉장히 오래 걸릴 것이다. 단어를 효율적으로 찾으려면 '어디쯤에 단어가 있을지 예측해서 탐색 범의를 줄이는 방법'을 활용하면 좋을 것이다.

### 1.1.4. 알고리즘 개선하기

알고리즘은 세상에 있는 여러 문제들을 풀기 위해 필요하다. 하지만 아무 알고리즘이나 필요한 것은 아니다. 예를 들어 앞에서 언급했던 '알고리즘의 예(1)'처럼 비효율적인 알고리즘은 데이터가 많아졌을 때 처리 시간이 오래 걸릴 것이다.

#### 폭발적인 계산 횟수

계산 횟수가 비정상적으로 많은 예를 살펴보자. 아주 단순히 생각하면, 모든 경우의 수를 계산해보는 방법을 사용할 수 있다.

> ex) A 편의점은 다음과 같은 60개의 물건을 팔고 있다. 5000원을 갖고 가장 많은 칼로리를 섭취하려면 어떤 물건들을 구매해야 하는가?
>
> | 물건   | 물건1   | 물건2   | 물건3   | ...  | 물건60  |
> | ------ | ------- | ------- | ------- | ---- | ------- |
> | 가격   | 1200원  | 1640원  | 1280원  | ...  | 2770원  |
> | 칼로리 | 144kcal | 174kcal | 211kcal | ...  | 319kcal |

이 문제는 2.4절에서 자세히 다루므로 지금 이해할 필요는 없다. 결론적으로 물건의 수가 하나 늘어날 때마다 조합할 수 있는 경우의 수가 2배로 늘어난다. 그래서 물건이 60개라면, 경우의 수가 115경 가지가 나온다.

#### 좋은 알고리즘으로 계산하기

이러한 문제는 컴퓨터의 계산 속도 한계를 간단히 넘어버린다. 따라서 보다 적은 수의 계산 횟수로 같은 결과를 구할 수 있는 알고리즘으로 개선해야 한다. 세상에 있는 수많은 문제는 이미 만들어져 있는 알고리즘을 응용해서 효율적으로 풀 수 있다. 따라서 고전적인 알고리즘들을 공부해 두어야 한다.

## 1.2 왜 알고리즘에 수학이 필요할까?

알고리즘을 배우려면 수학적인 지식과 수학적인 접근 방법이 필요하다.

### 1.2.1. 알고리즘의 이해와 수학

일단 알고리즘을 이해하려면 수학이 필요하다. 간단한 예로 "원주율 pi ≒ 3.14의 값을 최대한 정확하게 구하는 문제"가 있다고 해보자.

한 변이 1cm인 정사각형 영역 위에 랜덤하게 점을 찍고, "왼쪽 아래 꼭짓점을 중심으로 하는 반원 1cm인 원 내부에 들어간 점의 비율"에 4를 곱하면, 원주율을 구할 수 있다. 

그런데 어떻게 이런 알고리즘을 사용해서 원주율을 구할 수 있는가? 이를 이해하려면 수학 분야 중에 하나인 통계학의 기본에 대해 알아야 한다. 

### 1.2.2. 알고리즘 성능 평가와 수학

알고리즘의 성능을 어림잡으려면, "계산 횟수" 또는 "복잡도" 라는 개념이 중요하다. 마찬가지로 이를 이해하기 위해서도 수학이 필요하다.

예를 들어서 1.1절에서 "1부터 100까지의 정수를 모두 더해 주세요"라는 문제를 생각해보면, 숫자를 하나씩 더했을 때 99번의 계산이 필요하며, 이것은 비효율적이라고 설명했다. 이를 "1부터 1000까지의 정수를 모두 더해 주세요"라는 문제로 변경한다면, 숫자를 하나씩 더했을 때 999번의 계산이 필요했을 것이다.

그런데 일반적으로 프로그래밍 문제는 100 또는 1000뿐만 아니라, 모든 경우에 작동해야 한다. 따라서 100 또는 1000이라는 정해진 숫자를 N으로 바꿔, "1부터 N까지의 정수를 모두 더해 주세요" 같은 문제로 변경한다. 이러한 문제의 계산 횟수를 식으로 만든다면, N -1회가 된다. 이 시점에서 이미 중학교 수학 시간에 배우는 문자식과 함수가 사용된다.

그리고 1.1.4항에서 소개한 것처럼 알고리즘에 따라서는 계산 횟수가 2<sup>N</sup>과 같이 되거나 logN처럼 로그함수가 되기도 한다. 알고리즘을 잘 다루려면 이러한 로그 함수의 특징도 이해해야 한다.

### 1.2.3. 이론적 사고력과 수학

좋은 알고리즘을 생각할 수 있는 힘을 기르려면, 논리적인 사고력과 접근 방법이 필요하다. 예를 들어서 1.1절에서 살펴보았던 계산 문제에서는 "합계가 101이 되는 쌍으로 분할한다"라는 접근 방법이 필요하다. 이 외에도 수를 블록으로 생각하고, "동적 변형(도형의 넓이를 바꾸지 않으면서 다른 도형으로 바꾸는 것)을 한다"라는 식으로 접근할 수도 있다.

일반적으로 알고리즘 문제를 풀 때는 수학을 활용한 고전적인 형태의 사고 흐름이 있다. 예를 들어서 다음과 같은 것들이 유명하다. 따라서 수학을 배우면 이와 관련된 문제를 쉽게 풀 수 있다.

* 규칙성 찾기(5.2절)
* 작은 문제 여러 개로 분할하기(5.6절)
* 조건을 적절하게 변경하기(5.10절)
* 상태 수 생각하기(5.10절)

## 1.3. 이 책의 구성 / 이 책을 읽는 방법

### 1.3.1. 이 책의 구성

#### 2장

2장에서 알고리즘을 배울 때 필요한 기초적인 수학 지식을 정리한다. 예를 들어서 프로그램을 만들 때 중요한 2진법과 비트 연산, 프로그램 계산 횟수 예측에 중요한 지수 함수와 로그 함수, 알고리즘의 성능을 표기할 때 사용하는 점근 표기법(또는 빅-O 표기법, 란다우 표기법)을 설명한다.

#### 3장과 4장

3장과 4장에서는 이진 탐색, 정렬, 몬테카를로법, 동저계획법, 그래프 탐색, 유클리드 호제법, 에라토스네스의 체, 수치 계산 등 다양한 알고리즘을 소개한다. 

#### 5장

5장에서는 고전적인 수학적 접근 방법을 9가지 포인트로 나누어 정리한다. 알고리즘을 사용해서 여러 문제를 해결하려면, 단순하게 수학을 공부하거나 여러 알고리즘을 이해하는 것만으로는 부족하다. 해결 방법을 생각하는 힘 자체가 필요하다. 5장에서는 여러 구체적인 예를 사용해서, 알고리즘을 생각해낼 때 필요한 접근 방법들을 설명한다.

#### 최종 확인 문제

마지막으로 30개의 최종 확인 문제를 통해, 이 책에서 배웠던 내용을 복습한다.

#### 이 책의 소스 코드

http://github.com/wikibook/algorithm-math

#### desmose.com으로 그래프 그려보기

https://www.desmos.com/?lang=ko

## 2.4. 계산 횟수 예측하기 : 전체 탐색과 이진 탐색

이번 절에서는 복잡도(계산 횟수 등)를 예측하는 방법에 대해서 알아보고, 복잡도를 평가할 때 사용되는 'O 표기'의 개념을 알아본다.

### 2.4.1. 도입 : 계산 횟수가 중요한 이유

컴퓨터의 계산 속도에도 한계가 있다. 일반적으로 가정용 컴퓨터는 1초에 약 10억 회 정도 계산할 수 있다. 2.4.6항에서 설명하는 '효율이 좋지 않은 알고리즘'의 경우, 처리해야 하는 데이터가 많아졌을 때, 계산 횟수가 1경 회를 쉽게 넘어간다. 이런 문제를 가정용 컴퓨터로 해결하려 하면, 몇 시간을 기다려도 계산 결과가 나오지 않는다. 

따라서 프로그램을 작성하기 전에 '어느정도 계산 횟수가 나오는가?', '실제로 실행했을 때 어느 정도 시간이 걸리는가?'를 예측할 수 있어야 한다.

### 2.4.2 계산 횟수란?

계산 횟수는 '답을 낼 때까지 수행하는 계산의 횟수'를 의미한다.

'대략 N회 계산한다'처럼 계산 횟수를 예측하는 접근 방법이 있다. 이는 이후에 설명하는 란다우 표기법(O 표기법)과 관련이 있다.

### 2.4.3. 계산 횟수의 예(1) : 정수 시간

다음과 같은 문제를 생각해보자.

> ex) 정수 N이 주어졌을 때, 2N + 3의 값을 출력하는 프로그램을 작성하시오, 예를들어 N = 100이라면, 203이라고 출력하시오.
>
> 제약 : 1 ≤ N ≤ 100
>
> 실행 제한 시간 : 1초
>
> 입력 : N
>
> 출력 : 답을 출력하시오.
>
> 입력 예 : 
>
> ```
> 100
> ```
>
> 출력 예 :
>
> ```
> 203
> ```
>
> N = 100일 때, 2N + 3 = 203이다.

이 문제는 정수 N을 입력하고 2*N+3을 출력하는 프로그램을 작성하면 풀 수 있다. 프로그램의 계산 횟수를 예측해보자. 입출력을 제외하면, 프로그램은 다음과 같은 계산을 처리한다.

1. 일단 2*N을 계산한다.
2. 이어서 1의 결과와 3을 더한다.

따라서 모두 2회 계산한다. 이처럼 계산 횟수가 정수로 나오는 알고리즘을 "정수 시간을 가졌다"라고 하며, 실행 시간이 입력 데이터의 크기와 상관없이 고정된다는 특징이 있다.

*코드 2.4.1) 2N + 3의 값을 출력하는 프로그램*

```python
N = int(input())
print(2*N + 3)
```

### 2.4.4. 계산 횟수의 예(2) : 선형 시간

이어서 다음 문제를 생각해 본다.

> ex) 정수 N, X, Y가 주어졌을 때, N 이하의 양의 정수 중에서 X의 배수 또는 Y의 배수인 것을 몇 개인지 출력하는 프로그램을 작성하시오. 예를 들어서 N = 15, X = 3, Y = 5라면, 15 이하 양의 정수 중 3의 배수 또는 5의 배수인 것을 세면 된다. 3, 5, 6, 9, 10, 12, 15이므로 7개이다. 따라서 7을 출력하면 된다.
>
> 제약 : 1 ≤ N ≤ 10^8, 1 ≤ X ≤ Y ≤ 10^6, 입력은 모두 정수
>
> 실행 시간 제한 : 1초
>
> 입력 : N, X, Y
>
> 출력 : 답을 출력하시오.
>
> 입력 예 :
>
> ```
> 15 3 5
> ```
>
> 출력 예 :
>
> ```
> 7
> ```
>
> 15 이하 양의 정수 중에서 3 또는 5의 배수인 것은 3, 5, 6, 9, 10, 12, 15로 7개이므로, 7을 출력하면 정답이다.

이 문제는 "1은 X 또는 Y의 배수인가?", ..., "N은 X 또는 Y의 배수인가?" 처럼 하나하나 확인하는 형태로 풀 수 있다. 이 알고리즘을 구현한다면, 코드 2.4.2와 같다.

그럼 계산 횟수를 이론적으로 예측해보자. for 반복문의 인덱스 i는 1, 2, 3, 4 ..., N으로 차례대로 증가해서 N개가 나온다. 따라서 계산 횟수는 대략 N회이다.

이와 같은 계산 횟수가 나오는 알고리즘은 (N에 대해서) 선형 시간을 가졌다고 이야기하며, 입력 데이터의 크기가 10배 또는 100배로 늘어나면, 실행 시간도 10배 또는 100배가량 늘어난다는 특징이 있다. 참고로 for 반복문이 중첩되지 않았을 경우, 이와 같은 계산 횟수가 많이 나온다.

*코드 2.4.2) X 또는 Y의 배수 개수를 출력하는 프로그램*

```python
# 입력
N, X, Y = map(int, input().split())

# 답 구하기
cnt = 0
for i in range(1, N + 1):
    # mod 계산은 2.2절 참고
    if i % X == 0 or i % Y == 0:
        cnt += 1
        
# 출력
print(cnt)
```

### 2.4.5. 계산 횟수의 예(3) : 전체 탐색 계산 횟수

이어서 다음 문제를 생각해 본다.

> ex) 붉은색과 파란색 카드가 한 장씩 있다. 각각의 카드에는 1 이상, N이하의 정수를 하나씩 적을 수 있다. 두 카드에 적혀 있는 정수의 합계가 S 이하가 되는 방법이 몇 가지인지 출력하는 프로그램을 작성하시오.
>
> 예를 들어 N = 3, S = 4라면 6이라고 출력하면 된다. 1 이상 3 이하의 정수를 적는 방법은 모두 9가지이지만, 그중에서 합계 4 이하가 되는 방법은 6가지이기 때문이다.
>
> 제약 : 1 ≤ N ≤ 1000, 1 ≤ S ≤ 2000, 입력은 모두 정수
>
> 실행 시간 제한 : 2초
>
> 입력 : N S
>
> 출력 : 답을 출력하시오
>
> 입력 예 :
>
> ```
> 3 4 
> ```
>
> 출력 예 :
>
> ```
> 6
> ```
>
> 합계가 4 이하가 되는 작성 방법은 다음과 같이 6가지이다.
>
> * 붉은색 카드에 1, 파란색 카드에 1
> * 붉은색 카드에 1, 파란색 카드에 2
> * 붉은색 카드에 1, 파란색 카드에 3
> * 붉은색 카드에 2, 파란색 카드에 1
> * 붉은색 카드에 2, 파란색 카드에 2
> * 붉은색 카드에 3, 파란색 카드에 1

일반적으로 나올 수 있는 모든 패턴을 확인하는 방법을 "전체 탐색"이라고 한다. 전체 탐색은 가장 단순한 알고리즘이므로 문제를 풀 때 가장 먼저 생각해 볼 수 있는 접근 방법이다. 하지만 전체 탐색이 현실적인 시간 내에 실행될 수 있는지를 꼭 함께 생각해보아야 한다.

이번 카드 문제를 전체 탐색으로 풀어본다. 카드에 숫자를 적는 방법을 N을 활용한 식으로 나타내믄 N^2가지가 된다. 따라서 계산 횟수는 약 N^2회라고 할 수 있다. 참고로 왜 N x N가지가 되는지 잘 모르겠다면 카드에 숫자를 적는 방법을 정사각형 모양으로 나열했을 때, 크기가 N x N이기 때문에 N^2가지가 되는 것이다.

![image-20240427001756172](/home/oem/algorithm/assets/image-20240427001756172.png)

이번 문제의 제약은 N ≤ 1000 이므로, 최대 1000 x 1000 = 10^6회 가량 계산해야 한다. 일반적으로 가정용 컴퓨터의 계산 속도는 10초에 10^9회 정도이므로, 코드 2.4.3처럼 구현하면 이번 문제의 실행 시간 제한인 2초 내에 프로그램의 실행이 종료될 것이다. 프로그램의 실행 시간은 이와 같은 방법으로 예측해 볼 수 있다.

*코드 2.4.3) 2장의 카드 전체 탐색하기*

```python
# 입력
N, S = map(int, input().split())

# 답 구하기
answer = 0
for i in range(1, N + 1):
    for j in range(1, N + 1):
        if i + j <= S:
            answer += 1
            
# 출력
print(answer)
```

계산 횟수가 약 N^2인 알고리즘은 입력 데이터가 10배 또는 100배로 증가할 때, 실행 시간이 약 100배 또는 10000배로 증가한다는 특징이 있다. 다음 표는 N의 값에 따라서 N^2의 값이 어떻게 변하는지 나타낸 것이다. 10^6 이상부터는 노란색으로 표시했으며, 10^9 이상부터는 붉은색으로 표시했다. 컴퓨터의 계산 횟수를 생각해 보면, N = 10000 정도는 1초 내에 계산할 수 있다. 하지만 N = 100000 이상부터는 시간이 조금씩 걸린다는 것을 알 수 있다. 참고로 for 반복문을 이처럼 이중으로 중첩해서 사용하면, 이와 같은 계산 횟수가 나오는 경우가 많다.

![image-20240427003025813](/home/oem/algorithm/assets/image-20240427003025813.png)

### 2.4.6. 계산 횟수의 예(4) : 전체 탐색과 지수 시간

조금 설정을 변경해서, 다음 문제를 생각해보자.

> ex) N장의 카드가 차례대로 나열이 되어 있다. 왼쪽에서 i(1<=i<=N)번째 카드에는 정수 Ai가 적혀있다. 카드 중에서 몇 개를 선택해서, 합계가 S가 되는 방법이 있는지 확인하시오. 예를 들어서 다음과 같이 입력하면, 카드 1, 3을 선택했을 때 합계 11이 되므로, 답은 Yes이다.
>
> * N = 3
> * S = 11
> * (A1, A2, A3) = (2, 5, 9)
>
> 제약 : 1 <= N <= 10000, 1 <= S <= 10000, 입력은 모두 정수
>
> 실행 시간 제한 : 1초
>
> 입력 :
>
> N S
>
> A1, A2, A3, ..., AN
>
> 출력 : 합계가 S가 되게 만드는 방법이 존재하면 Yes, 없으면 No를 출력하시오.
>
> 입력 예 :
>
> ```
> 3 11
> 2 5 9
> ```
>
> 출력 예 :
>
> ```
> Yes
> ```
>
> 입력 예 :
>
> ```
> 4 11
> 3 1 4 5
> ```
>
> 출력 예 :
>
> ```
> No
> ```

2.4.5항과 마찬가지로 카드 선택 방법을 전체 탐색하는 방법으로 생각해보자.

예를 들어서 N = 1이라면 "카드1을 선택한다", "카드1을 선택하지 않는다"라는 2가지 경우가 있을 것이다. 또한 N = 2라면 4가지, N = 3이라면 8가지 경우가 있을 것이다. 이 정도의 탐색 패턴 수라면 손으로도 어느 정도 문제를 풀 수 있다.

하지만 카드의 수가 점점 늘어날수록 패턴의 수가 급격하게 증가한다. N = 4일때는 16가지, N = 5일 때는 32가지 패턴을 모두 확인해야 한다. 즉, 패턴 수는 2^N가지이다.

N이 늘어날 수록 패턴 수는 기하급수적으로 증가하므로 알고리즘을 더 효율적으로 설계해야 한다. 일반적으로 이러한 상황에서는 동적계획법(참고 : 3.7절)을 사용해서, 효율적인 알고리즘을 만들 수 있다.

### 2.4.7. 계산 횟수의 예(5) : 이진 탐색과 로그 함수

이전 절에서는 계산에 시간이 오래 걸리는 알고리즘 예를 소개했다. 반대의 경우도 존재한다. 다음 문제를 생각해보자.

> ex) 철수는 1 이상 8 이하의 정수를 떠올렸다. 철수에게 다음과 같은 질문을 하였다.
>
> * "떠올린 숫자는 OO 이하인가?"
>
> 가능한 한 적은 횟수로 질문해서, 철수가 떠올린 숫자를 맞추시오.

가장 기본적인 방법은 1부터 차례대로 질문하는 것이다. 이 방법에서 6 이하인지를 물었을 때 처음으로 yes라는 답이 나왔을 경우, 답이 6이라는 것을 알 수 있다. 이러한 알고리즘을 선형 탐색법이라고 부른다.

하지만 이 방법은 효율이 좋지 않다. 예를 들어 철수가 떠올린 숫자가 8 이하면, 8번 질문을 해야 한다.

처음에 4 이하인지를 묻는 것처럼 남은 선택지에서 중간 숫자를 사용한 질문을 한다면, 곧바로 선택지가 4개로 좁혀진다.

* 예의 경우 : 답은 1, 2, 3, 4 중에서 하나
* 아니오의 경우 : 답은 5, 6, 7, 8 중에서 하나

이후 질문에서도 선택지를 절반으로 나누는 질문을 한다면, 선택지 수가 빠르게 줄어든다. 따라서 어떠한 경우에도 3번의 질문이면 답을 맞출 수 있다. 이와 같은 방법을 이진 탐색법이라고 이야기한다.

문제의 설정을 일반화해보자. 철수가 1 이상 N 이하의 정수를 떠올리는 경우의 계산 횟수는 어떻게 되는가? 간단한 예로 음수가 아닌 정수 B를 사용해서 N = 2^B라고 표현해서 생각해보자. 1회의 질문으로 선택지가 절반씩 줄어든다. 2^B = N이므로, B = log<sub>2</sub>N이다. 따라서 N을 활용해서 표현하면, log<sub>2</sub>N이 된다는 것을 알 수 있다.

그렇다면 N이 2^B 형태가 아닌 경우는 어떻게 되는가? 결론적으로 질문 횟수가 log<sub>2</sub>N회가 되므로 N = 10^6이라고 해도, 20번의 질문이면 답을 구할 수 있다. N이 증가해도 로그 함수 log<sub>2</sub>N은 빠르게 증가하지 않는다. 그래서 계산 횟수로 나올 경우 해당 알고리즘의 효율이 상당히 좋다.

### 2.4.8. 란다우의 O표기법

지금까지 다양한 계산 횟수에 대해서 소개하면서, 다음과 같은 표현을 사용했다.

* 계산 횟수가 대략 N회이다.
* 계산 횟수가 대략 N^2회이다.
* 계산 횟수가 대략 2^N회이다.

란다우의 O 표기법을 사용하면 이와 같은 표현을 간단하게 할 수 있다. 예를 들어 2.4.2항에서 설명한 알고리즘의 경우 "대략 N회 계산한다"가 아니라 "이 알고리즘의 복잡도는 O(N)이다" 또는 "이 알고리즘은 O(N) 시간으로 동작한다"라고 말할 수 있다. 조금 난이도가 있지만, 엄밀하게 표현한다면 다음과 같이 표현할 수 있다.

```
데이터의 크기를 N이라고 할 때, 알고리즘 A의 복잡도를 T(N)이라 한다. 그리고 P(N)이라는 함수가 있다고 가정한다. 어떤 상수 c가 존재하고, N이 아무리 커지더라도 T(N)<=c<=P(N)일 때, 알고리즘 A의 복잡도를 O(P(N))이라고 정의한다.
```

일반적인 경우, 복잡도 T(N)을 나타내는 O 표기법 내부에 있는 P(N)은 다음과 같은 과정에 따라 결정할 수 있다.

1. N이 큰 값일 때, T(N) 안에서 가장 중요한 항만 남기고, 이 외의 항은 제외한다.
2. 정수 부분(예 : 7N^2에서 7)을 제외한다.
3. 최종적으로 남는 것을 P(N)으로 한다.

참고로 항의 중요도는 원칙적으로 다음과 같은 순서라고 생각하면 된다.

1. 지수 내에서는 밑의 크기가 중요
2. 밑이 같은 경우 다항식이 추가되어 있는지가 중요
3. 차수가 같은 경우에 log가 붙어 있는지가 중요

이와 같은 순서가 되는 이유는 N = 1000처럼 큰 수를 대입하면 쉽게 이해할 수 있다. 예를 들어 계산 횟수가 T(N) = N^2 + 5N이라면, 각 항에 N을 대입했을 때 N^2 = 10^6, 5N = 5000이다. 명확하게 N^2라는 항이 계산 횟수의 병목이 된다. 이는 N보다 N^2의 중요도가 더 높기 때문이다. 다른 경우도 마찬가지이다.

이어서 3개의 구체적인 예로 복잡도를 O 표기법으로 표기하는 과정을 설명하면 다음과 같다. 참고로 복잡도 오더의 내용에 로그 함수가 포함되어 있는 경우, 관습적으로 O(logN)처럼 밑을 생략해서 작성하는 경우가 많다.

* 예 A

  알고리즘 A의 복잡도는 다음과 같음

  T<sub>A</sub>(N) = 2N^2 + 5N + 10

  가장 중요한 항은 2N^2이므로

  알고리즘 A의 복잡도는 O(N^2)

* 예 B

  알고리즘 B의 복잡도는 다음과 같음

  T<sub>B</sub>(N) = 2log<sub>2</sub>N + 1

  가장 중요한 항은 2log<sub>2</sub>N이므로

  알고리즘 B의 복잡도는 O(logN)

* 예 C

  알고리즘 C의 복잡도는 다음과 같음

  T<sub>C</sub>(N) = 2^N + 5N^3 + 5N^2 + 9

  가장 중요한 항은 2N이므로

  알고리즘 C의 복잡도는 O(2^N)

### 2.4.9 복잡도와 알고리즘의 예

다음 표는 고전적인 알고리즘과 그 복잡도를 함께 정리한 것이다. 다양한 성능을 가진 알고리즘이 있다는 것을 알 수 있다.

| 복잡도       | 알고리즘                                                     |
| ------------ | ------------------------------------------------------------ |
| O(1)         | 점과 선분의 거리 계산(4.1절)                                 |
| O(logN)      | 이진법으로 변환(2.1절) / 이진 탐색법(2.4절) / 유클리드 호제법(3.2절) / 반복 제곱법(4.6절) |
| O(sqrt(N))   | 소수 판정법(3.1절)                                           |
| O(N)         | 선형 탐색법(2.4)                                             |
| O(Nlog logN) | 에라토스테네스의 체(4.4절)                                   |
| O(NlogN)     | 병합정렬(3.6절) / 인터벌 스케줄링 문제(5.9절)                |
| O(N^2)       | 선택정렬(3.6절) 등                                           |
| O(N^3)       | 행렬곱 연산(4.7절) / 플로이드 - 위셜 알고리즘 등             |
| O(2^N)       | 조합 전체 탐색(2.4절 / 칼럼2)                                |
| O(N!)        | 순열 전체 탐색 ※ N!에 대해서는 2.5절 참고                    |

### 2.4.10. 복잡도 비교

입력 데이터의 크기를 N이라고 했을 때, 계산 시간의 관계를 표료 정리하면 다음과 같다. 

![image-20240427025257227](/home/oem/algorithm/assets/image-20240427025257227.png)

복잡도가 O(2^N) 또는 O(N!) 등이 되는 지수 시간 알고리즘은 계산 횟수의 증가 폭이 커서, N이 100정도만 되어도 현실적인 시간 내에 계산할 수 없다. 반면 O(logN)은 계산 시간의 증가 폭이 작다.

### 2.4.11. 복잡도와 관련된 주의 사항

다음은 이번 절의 마지막으로 복잡도와 관련된 주의 사항이다.

#### 시간 복잡도와 공간 복잡도

복잡도를 평가하는 방법으로 '알고리즘의 계산 횟수를 나타내는 시간 복잡도'와 '메모리 사용량을 나타내는 공간 복잡도'라는 2가지가 많이 쓰인다. 예를 들어 데이터의 크기 N에 대해서, 메모리 용량을 4N^2만큼 사용한다면, "이 알고리즘의 공간 복잡도는 O(N^2)이다"라고 말한다. 참고로 이 책에서 단순하게 "복잡도"라고 표현하면, 이는 시간 복잡도를 의미한다.

#### 최악 복잡도와 평균 복잡도

입력 데이터 크기가 같아도, 입력 데이터의 특성에 따라 계산 횟수가 달라질 수 있다. 추가적으로 난수를 사용하는 알고리즘(3.5절)은 운에 따라서 계산 횟수가 달라질 수도 있다. 일반적으로 가장 최악의 경우에서 계산 시간을 예측하는 경우가 많으며, 이를 최악 복잡도라고 부른다. 반면 평균적인 경우의 복잡도를 평균 복잡도라고 부른다. 참고로 대부분의 알고리즘은 평균 복잡도와 최악 복잡도가 일치한다.

#### 여러 개의 변수가 사용되는 경우

복잡도 예측에 여러 개의 변수가 사용되는 경우도 있다. 예를 들어 1부터 N까지의 합계를 계산한 후, 1부터 M까지의 합계를 계산하는 문제를 생각해보자. 차례대로 더했을 때의 계산 횟수는 N + M -2회이다. 여기서 병목이 되는 부분은 N, M으로 2개이다. 이때 복잡도는 O(N+M)처럼 표기한다.

## 연습문제

> 문제 2.4.1. N에 대해서 계산 횟수가 다음과 같을 때, 복잡도를 O 표기법으로 나타내시오
>
> 1. T<sub>1</sub>(N) = 2021N^3 + 1225N^2
> 2. T<sub>2</sub>(N) = 4N + logN
> 3. T<sub>3</sub>(N) = 2^N + N^100
> 4. T<sub>4</sub>(N) = N! + 100^N

> 문제 2.4.2. 다음 프로그램의 복잡도를 O 표기법으로 나타내시오.
>
> ```python
> for i in range(1, N + 1):
>     for j in range(1, N * 100):
>         print(i, j)
> ```

> 문제 2.4.3. log<sub>2</sub>N과 log<sub>10</sub>N은 최대 상수 배밖에 차이가 나지 않는다는 것을 증명하시오. 참고로 이는 란다우 O 표기법에서 O(logN)의 로그 밑을 생략하는 이유이다.

> 문제 2.4.4. 다음 표는 "N이 어느 정도의 크기를 가질 때, 대략 몇 회 계산하는가?"를 나타낸 표이다. 이 표를 완성하시오. 참고로 계산 횟수의 상수 배(예 : 10N^2에서 "10"부분)는 생략한다. 또한 log의 밑은 2로 계산한다.
>
> | 계산 횟수   | 실행 시간 예측 | NlogN      | N^2       | 2^N     |
> | ----------- | -------------- | ---------- | --------- | ------- |
> | 10^6회 이내 | 0.001초 이내   | N <= 60000 | N <= 1000 | N <= 20 |
> | 10^7회 이내 | 0.01초 이내    |            |           |         |
> | 10^8회 이내 | 0.1초 이내     |            |           |         |
> | 10^9회 이내 | 1초 이내       |            |           |         |

> 문제 2.4.5. 알고리즘 D를 구현한 프로그램을 N = 10, 12, 14, 16, 18, 20으로 실행했을 때, 실행 시간이 다음과 같이 나타났다. 알고리즘 D의 복잡도가 어느 정도인지 구하시오. 여기서 N은 데이터의 크기(예 : 카드의 장수)이다.
>
> | N         | 10      | 12      | 14      | 16      | 18      | 20       |
> | --------- | ------- | ------- | ------- | ------- | ------- | -------- |
> | 실행 시간 | 0.001초 | 0.006초 | 0.049초 | 0.447초 | 4.025초 | 36.189초 |

> 문제 2.4.6. 어떤 사전에 1000000개 정도의 단어가 사전 순서대로 적혀있다. 이 사전에서 특정 단어를 찾을 때 a -> aardvar -> aback -> ... 처럼 하나하나 단어를 찾으면, 시간이 많이 걸린다. 어떤 방법을 사용해야 효율적으로 찾을 수 있을지 생각하시오(힌트 : 이진 탐색법, 2.4.7항).

## 2.5 추가적인 기본 수학 지식

### 2.5.1. 소수

1과 자신만으로 나누어지는 2 이상의 정수를 "소수(prime number)"라고 부른다. 반대로 그렇지 않은 2 이상의 정수를 "합성수(composite number)"라고 부른다. 

### 2.5.2. 최대공약수와 최소공배수

2개 이상의 양의 정수에 공통되는 약수 중에서 가장 큰 것을 최대공약수라고 부른다.

또한 2개 이상의 양의 정수에 공통되는 배수 중에서 가장 작은 것을 최소공배수라고 부른다.

### 2.5.3. 팩토리얼(계승)

양의 정수 N이 있을 때, 1부터 N까지의 곱 1x2x3x4x ... xN을 N 팩토리얼(N의 계승)이라고 부르며, N!이라고 표기한다.

### 2.5.4. 수열 기본

수열이란 "수의 나열"이라는 의미이다. 간단한 예로 다음과 같은 모든 것이 수열이다.

* 1, 2, 3, 4, 5, ... (양의 정수를 작은 것부터 나열)
* 1, 4, 9, 16, ... (양의 정수를 제곱해서 나열)
* 3, 1, 4, 1, 5, 9, 2 ... (원주율의 숫자를 나열)

일반적으로 수열의 A의 앞에서 i번째에 있는 요소를 "i번째 항"이라고 부르며, A<sub>i</sub>라고 표기한다. 

#### 등차수열과 등비수열

고전적인 수열로 등차수열과 등비수열이 있다. 등차수열은 두 항의 차이가 일정한 수열, 등비수열은 두 항의 비율이 일정한 수열이다. 이 외에도 앞의 두 항을 더해서 만들어지는 피보나치 수열과 같이 다양한 규칙을 가지는 수열이 있다. 이처럼 이전 항에 따라서 수열의 값이 결정되는 관계식을 "점화식"이라고 부르며, 이와 관련된 자세한 내용은 3.7절에서 설명한다. 참고로, 점화식을 접근 방법으로 활용하면 다양한 알고리즘 문제를 해결할 수 있다.

#### 유한수열과 무한수열

수열을 "규칙을 갖고 무한하게 이어지는 것"이라 생각할 수 있겠으나, A = (9, 9, 8, 2, 4, 5, 3, 5, 3)처럼 규칙성 없이 유한한 수의 나열도 수열이다. 이처럼 마지막 항을 가진 수열을 유한수열이라 하며, 무한하게 항이 이어지는 무한수열과 구별한다. 또한 항의 수가 N인 수열은 "길이가 N인 수열"이라 부르기도 한다.

유한 수열은 프로그래밍에서 "배열/리스트"와 비슷한 것이다. 특별한 규칙 없이 단순하게 수가 N개 나열되어 있는 것을 생각하는 것도 좋다. 참고로 이 책을 포함해서 대부분의 프로그래밍 문제들은 유한수열의 항 형태를 사용해서 문제를 설명하는 경우가 많다.

### 2.5.5. 집합 기본

집합이란 여러 대상이 모여 있는 것을 말한다. 예를 들어서 "야구 동아리 멤버"와 같은 하나의 그룹을 "집합"이라고 부른다. 추가적으로 집합에 속하는 하나하나의 대상을 "원소"라고 부른다. 예를 들어 "야구 동아리 멤버"라는 집합의 원소는 A, B, C로 3명이다.

기본적으로 집합은 다음 페이지의 예처럼 요소를 나열하는 형태로 표기한다. 집합에서 순서는 아무 의미가 없다. 순서에 의미가 없다는 것을 반드시 기억하자.

또한, 문제에서 생각할 수 있는 모든 원소를 "전체 집합"이라고 부르며, U라고 표기하는 경우가 많다. 

#### 집합과 관련된 용어

| 용어              | 기호  | 설명                                                   |
| ----------------- | ----- | ------------------------------------------------------ |
| 공집합            | { }   | 아무것도 포함되지 않은 집합                            |
| 포함 관계         | x ∈ A | 집합A에 요소 x가 포함된다는 의미                       |
| 집합 A의 원소 수  | \|A\| | 집합 A에 속하는 요소 수                                |
| 교집합            | A ∩ B | 집합 A와 B 공통 부분(양쪽 모두에 포함되는 원소의 집합) |
| 합집합            | A ∩ B | 집합 A와 B 중에서 적어도 한쪽에 포함되는 부분          |
| A는 B의 부분 집합 | A ⊂ B | 집합 A의 요소가 모두 집합 B에 포함된다는 의미          |

### 2.5.6. 필요조건과 충분조건

어떤 조건 X를 만족하기 위해서 반드시 조건 A를 만족해야 한다면, "조건 A는 조건 X의 필요조건"이라고 표현한다. 예를 들어 "시험 점수가 60점 이상"은 "시험 점수가 80점 이상"의 필요조건이다.

반면 조건 A만 충족하면, 조건 X가 충족될 때 "조건 A는 조건 X의 충분조건"이라고 표현한다. 예를 들어 "시험 점수가 80점 이상"은 "시험 점수가 60점 이상"의 충분조건이다.

조금 더 수학적인 예를 들자면, 조건 X를 "N은 3 이상인 소수"라고 할 때

* "N이 홀수이다"는 조건 X의 필요조건
* "N이 5 또는 11이다"는 조건 X의 충분조건

이다. 이를 집합으로 표현하면, 범위가 넓은 쪽이 범위가 좁은 쪽(부분집합)의 필요조건이고, 범위가 좁은 쪽(부분집합)이 충분조건이다.

추가적으로 조건X가 조건Y의 필요조건이면서도 충분조건인 경우, "조건 X는 조건 Y의 필요충분조건" 또는 "조건 X와 조건 Y는 동치"라고 이야기한다.

필요조건과 충분조건은 알고리즘의 정당성을 증명할 때(5.8절), 문제의 조건을 변경해서 접근할 때(5.10절) 등의 상황에서 사용한다.

### 2.5.7. 절대 오차와 상대 오차

근삿값 a와 이론값 b의 오차를 평가하는 방법으로 다음과 같은 두 가지 방법이 있다.

| 용어      | 의미             | 계산식        |
| --------- | ---------------- | ------------- |
| 절대 오차 | 숫자 자체의 차이 | \|a - b\|     |
| 상대 오차 | 오차의 비율      | \|a - b\| / b |

예를 들어서 근삿값이 103, 이론값이 100이라면 절대 오차는 3이고 상대 오차는 0.03이다. 참고로 절대 오차가 같더라도 상대 오차가 다른 경우가 있을 수 있다.

알고리즘을 설계할 때는 반드시 오차를 함께 생각해야 한다. 예를 들어서 몬테카를로법(3.5절), 부동소수점 숫자(5.10절) 등에서 사용한다.

### 2.5.8. 폐구간, 반개구간, 개구간

수학과 알고리즘에서는 다음과 같은 표기를 사용해서 구간을 나타낸다.

| 이름       | 기호   | 의미                |
| ---------- | ------ | ------------------- |
| 폐구간     | [l, r] | l이상, r이하인 구간 |
| 반개구간   | [l, r) | l이상, r미만인 구간 |
| (반개구간) | (l, r] | l초과, r이하인 구간 |
| 개구간     | (l, r) | l초과, r미만인 구간 |

특히 배열 인덱스처럼 숫자가 정수라는 것을 알 때, 예를 들어 반개구간 [l, r)은 l, l+1, ..., r-1을 의미한다.

참고로 반개구간 등의 접근 방식은 분할 정복법, 병합 정렬(3.6절)에서 사용한다.

### 2.5.9. 시그마 기호

시그마 기호는 총합을 나타내는 기호이다.

시그마를 중첩해서 사용할 수도 있는데, 예를 들어 다음 식은 2<=i<=3, 4<=j<=5를 만족하는 모든 정수 조합 (i, j)로 i + j 값을 계산한 뒤 합한 값을 의미한다. 

sigma(i = [2, 3])sigma(j = [4, 5]) {i + j} = 28

아래 그림은 i와 j를 더한 값을 나타낸 표인데, 파란 부분으로 칠해진 부분이 위의 식에 해당하는 영역이며, 이 수를 모두 더하면 총합이 28이 나온다.

![image-20240427035819010](/home/oem/algorithm/assets/image-20240427035819010.png)

참고로 시그마는 3번 이상 중첩하는 것도 가능하다(연습문제 2.5.5). 시그마 기호는 수학적 접근 방법 편에서 "더한 횟수를 생각하는 테크닉(5.7절)", "대칭성을 사용하는 테크닉(5.10절)" 등에서 사용해본다.

### 2.5.10. 합의 공식

일부 시그마 계산은 다음과 같이 간단하게 계산할 수 있다. 예를 들어 1.1절에서 소개한 "1부터 100까지의 정수를 모두 더하는 문제"는 공식을 활용해서 100 x 101 ÷ 2 = 5050으로 계산할 수 있다. 

추가적으로 c가 1미만인 양의 정수라면, 1 + c + c^2 + c^3 + ...의 값이 1/(1-c)이다. 특히 c = 1/2라면, 1 + 1/2 + 1/4 + 1/8 + ... = 2이다. 

이번 절에서 소개한 합의 공식은 기댓값을 사용한 알고리즘(3.4절), 계산 횟수를 예측할 때 사용한다.

### 2.5.11. 이후에 배우는 새로운 수학 지식

마지막으로 3장과 4장에서 새로 배울 수학 지식들을 미리 이름만이라도 소개한다. 3장과 4장은 알고리즘을 다루지만, 관련된 수학 지식도 함께 병행해서 설명할 예정이다.

* 귀류법(3.1절)
* 곱의 법칙, <sub>n</sub>P<sub>r</sub>, <sub>n</sub>C<sub>r</sub>(3.3절)
* 확률과 기댓값(3.4절)
* 평균과 표준편차(3.5절)
* 수열 점화식(3.7절)
* 미분법과 적분법(4.3절, 4.4절)
* 벡터와 행렬(4.1절, 4.7절)
* 그래프 이론(4.5절)
* 모듈로 역수(4.6절)

## 연습 문제

> 문제 2.5.1. 다음두 값을 각각 계산하시오.
>
> sigma(i = [1, 100]) {i}
>
> sigma(i = [1, 3]) sigma(j = [1, 3]) {i*j}

> 문제 2.5.2. 집합 S = {2, 4, 7}, T = {2, 3, 8, 9}가 있을 때, 다음 질문에 답하시오.
>
> 1. |S|, |T|의 값을 구하시오.
> 2. S ∪ T를 구하시오.
> 3. S ∩ T를 구하시오.
> 4. S의 부분 집합 중 공집합이 아닌 집합들을 모두 적으시오.

> 문제 2.5.3. 1 이상 20 이하의 정수 N을 입력받고, N!을 출력하는 프로그램을 만드시오.
>
> 제약 : 1 <= N <= 20, N은 정수
>
> 입력 : N
>
> 출력 : 답을 출력
>
> 입력 예
>
> ```
> 5
> ```
>
> 출력 예
>
> ```
> 120
> ```

> 문제 2.5.4. 양의 정수 N을 입력받고, N 이하의 소수를 작은 순서대로 출력하는 프로그램을 작성하시오. 이 문제는 에라토스테네스의 체(4.4절)를 사용하면 복잡도 O(NlogN)으로 풀 수 있다. 하지만 일단 지금은 O(N^2)으로 풀어도 좋다.
>
> 제약 : 2 <= N <= 3000, N은 정수
>
> 입력 : N
>
> 출력 : N 이하의 소수를 오름차순으로 출력하시오. 각각의 소수 사이에는 띄어쓰기를 하나씩 넣는다.
>
> 입력 예
>
> ```
> 10
> ```
>
> 출력 예
>
> ```
> 2 3 5 7
> ```

> 문제 2.5.5. 프로그램을 작성하지 않고, 다음 값을 계산하시오
>
> sigma(a = [1, 4]) sigma(b = [1,4]) sigma(c = [1,4]) {abc}

> 문제 2.5.6.
>
> 반개구간 [a, b)와 반개구간 [c, d)가 공통 부분을 가지려면, 어떤 조건이 필요한지 식으로 표현하시오.

> 문제 2.5.7. 다음 프로그램의 실행이 종료되었을 때, cnt에 어떤 값이 들어있을지 예측하시오. 추가적으로 프로그램의 복잡도 O 표기법으로 나타내시오.
>
> ```python
> cnt = 0
> for i in range(1, n + 1):
>     for j in range(1, n + 1):
>         cnt += 1
> ```

